---
title: Error handling
pcx_content_type: concept
weight: 4
---

# Error handling

Review how to handle errors (exceptions) generated by both your own Durable Object code as well as exceptions thrown by Durable Objects' infrastructure (such as overloads or network errors).

## How exceptions are thrown

Durable Objects can throw exceptions in one of two ways:

- Exceptions are thrown within the user code which implements a Durable Object class. The resulting exception will have a `.remote` property set to `True` in this case.
- Generated by Durable Object's infrastructure due to transient internal errors, or because you are sending too many requests to a single Durable Object, or when too many requests are queued due to slow or excessive I/O (external API calls or storage operations) within an individual Durable Object. Some of the exceptions generated by Durable Object's infrastructure will also have the `.remote` property set to `True`.

Refer to [Troubleshooting](/durable-objects/observability/troubleshooting/) to review the types of errors returned by a Durable Object and/or Durable Objects infrastructure and how to prevent them.

## Understanding stubs

A Durable Object stub is a client Object used to send requests to a remote Durable Object. To learn more about how to make requests to a Durable Object, refer to [Create Durable Objects stubs](/durable-objects/best-practices/create-durable-object-stubs-and-send-requests/) and [Access a Durable Objects from a Worker](/durable-objects/best-practices/access-durable-objects-from-a-worker/).

## Example

Any uncaught exceptions thrown by a Durable Object or its infrastructure will be propagated to the callsite of the client. Catching these exceptions allows you to retry creating the Durable Object stub and sending requests.

{{<Aside type="note" header="Durable Object stubs">}}

If any exception is thrown from a Durable Object stub, then the stub will need to be recreated prior to retrying requests. This is to provide E-order semantics as discussed in [create Durable Object stubs and send requests](/durable-objects/best-practices/create-durable-object-stubs-and-send-requests/#create-durable-object-stubs-and-send-requests).

JavaScript Errors with the property `.retryable` set to True are suggested to be retried if requests to the Durable Object are idempotent, or can be applied multiple times without changing the response. If requests are not idempotent, then you will need to decide what is best for your application. When the `.remote` property is set to True, `.retryable` will always be false because the platform cannot verify that application logic is safely retryable.

JavaScript Errors with the property `.overloaded` set to True should not be retried. If a Durable Object is overloaded, then retrying will worsen the overload and increase the overall error rate. When the `.remote` property is set to True, `.overloaded` will always be false because the platform will not suggest retrying overload errors.

{{</Aside>}}

```ts
export interface Env {
  ErrorThrowingObject: DurableObjectNamespace;
}

async function makeRequest(env: Env, id: DurableObjectId) {
  // Create the Durable Object stub here, because certain types of errors will break
  // the Durable Object stub, so you need to create it here to re-create the stub when
  // this function is called in your retry logic.
  const doStub = env.ErrorThrowingObject.get(id);
  const resp = await doStub.fetch("http://your-do/");

  return Response.json(resp);
}

export default {
  async fetch(
    req: Request,
    env: Env,
    ctx: ExecutionContext
  ): Promise<Response> {
    let userId = new URL(req.url).searchParams.get("userId") || "";
    const id = env.ErrorThrowingObject.idFromName(userId);
    // Try sending the request
    try {
      return await makeRequest(env, id);
    } catch (e: any) {
      if (e.retryable) {
        try {
          return await makeRequest(env, id);
        } catch (e: any) {
          // Retry still did not work, therefore return an error.
          return new Response("server error", { status: 500 });
        }
      }
    }
  },
};

export class ErrorThrowingObject implements DurableObject {
  constructor(state: DurableObjectState, env: Env) {
    // Any exceptions that are raised in your constructor will also set the
    // .remote property to True
    throw "no good";
  }

  async fetch(req: Request) {
    // Generate an uncaught exception
    // A .remote property will be added to the exception propagated to the caller
    // and will be set to True
    throw new Error("example error");

    // We never reach this
    return Response.json({});
  }
}
```

{{<Aside type="note" header="Production use">}}
The example above is only illustrative. Production applications using Durable Objects should retry multiple times using exponential backoff based on the same logic above.
{{</Aside>}}
