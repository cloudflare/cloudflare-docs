---
title: Presigned URLs
pcx_content_type: concept
---

# Presigned URLs

A presigned URL authorizes anyone with the URL to perform an action to the S3 endpoint for an R2 bucket. By default, the S3 endpoint requires an `AUTHORIZATION` header signed by your token. Each presigned URL contains S3 parameters and search parameters containing the signature information which replace the need for the `AUTHORIZATION` header. The performable action is restricted to a specific resource, an [operation](/r2/data-access/s3-api/api/), and has an associated timeout.

There are three kinds of resources in R2: 

1. **Account**: For account-level operations (such as `CreateBucket`, `ListBuckets`, `DeleteBucket`) the identifier is the account ID.
2. **Bucket**: For bucket-level operations (such as `ListObjects`, `PutBucketCors`) the identifier is the account ID, bucket name.
3. **Object**: For object-level operations (such as `GetObject`, `PutObject`, `CreateMultipartUpload`) the identifier is the account ID, bucket name, object path.

All parts of the identifier are part of the presigned URL. You cannot change the resource being accessed after the request is signed. For example, trying to change the bucket name to access the same object in a different bucket will not work.

Presigned URLs must have a defined expiry date. You can set an expiry date for your presigned URL from one second to 7 days in the future.  

Presigned URLs are generated offline with no communication with R2 and must be generated by an application with access to your R2 bucket's credentials.

## presigned URLs

In a typical design you have three ways to grant an application access to R2:
1. It has its own copy of the token.
2. It requests a copy of the token from some vault application and promises to not store that token locally permanently.
3. It requests a central application to give it a temporary URL (aka presigned URL) it can use to perform the action.

Scenarios 1 and 2 are quite similar - if that "less secure" application is compromised in some way,
the holder of the token can perform arbitrary actions. "Less secure" here is simply a fact of life
for any "complex" application (a central server / vault application is typically very limited
in functionality / more audited than others on your network).

Scenario 3 keeps the credential secret. As long as the "trusted" central application doesn't have it's key storage
system compromised, if the other applications leak a trusted URL the blast radius is limited to one operation on the
specific resource that was signed. Additionally, the central application can perform monitoring, auditing, logging tasks
so that you know when a request was made to perform an operation on some specific resource which can be helpful in case
of a security incident to understand what happened. Finally, the central application can perform policy enforcement.
For example, if you have an application responsible for uploading resources, you may want to restrict that it's uploading
to a specific bucket or folder within the bucket - the requesting application can obtain a JWT from your authorization
service to sign a request to the central application which uses the information contained in the JWT to validate the inbound
request parameters.

The highly trusted application, for example, can be a Cloudflare Worker because Worker secrets are cryptographically
impossible to obtain outside of your script running on the Workers runtime provided you don't store a copy of the
secret elsewhere or have your code log the secret somewhere. However, as mentioned above, presigned URLs are generated
outside of R2 and all that's required is the secret + an implementation of the signing algorithm, so you can generate them
anywhere.

Another potential use-case is if you're debugging your application and want to grant temporary access to a specific
test object in a production environment without needing to share the underlying token and remembering to revoke it.

## Presigned URL alternative with Workers

A valid alternative design to presigned URLs is to use a Worker with a binding that implements your security policy.
For example, let's say you wanted to restrict an application to only be able to upload to a specific URL. With presigned
URLs your central signing application might look like the following JavaScript code running on Cloudflare Workers, workerd,
or some other platform:

```
import { AwsClient } from 'aws4fetch'

const r2 = new AwsClient({ accessKeyId: '', secretAccessKey: '', service: 's3' , region: 'auto' });

export async function fetch(request: Request): Promise<Response> {
  const authorization = await authorize(request);
  if (authorization === undefined) {
    return new Response('invalid authorization', { status: 401 })
  }
  if (authorization.application === 'drop-box') {
    const url = new URL(request.url);

    // Check that the application is only requesting a URL
    if (url.pathname.startsWith('/my-upload-folder/')) {
      return new Response('invalid destination folder', { status: 403 });
    }

    const signedUrl = await r2.sign(new Request(
      `https://<DROPBOX BUCKET><ACCOUNT ID>.r2.cloudflarestorage.com${url.pathname}`, {
        method: 'PUT'
      }
    ), {
      signQuery: true,
      headers: {
        // The signed request is valid for 1 hour.
        'X-Amz-Expires': 3600,
      },
    });

    // Caller can now use this URL to upload to that object.
    return new Response(signedUrl, { status: 200 });
  }

  ... handle other kinds of requests
}
```

An equivalent Cloudflare Worker would look as follows:

```
interface Env {
  DROP_BOX_BUCKET: R2Bucket
}

export async function fetch(request: Request, env: Env): Promise<Response> {
  const authorization = await authorize(request);
  if (authorization === undefined) {
    return new Response('invalid authorization', { status: 401 })
  }
  if (authorization.application === 'drop-box') {
    const url = new URL(request.url);

    // Check that the application is only requesting a URL
    if (url.pathname.startsWith('/my-upload-folder/')) {
      return new Response('invalid destination folder', { status: 403 });
    }

    await env.DROP_BOX_BUCKET.put(url.substring(1), request.body);

    return new Response(null, { status: 200 });
  }

  ... handle other kinds of requests
}
```

Notice the total absence of any configuration or token secrets present in the
code. Instead, you would simply create a wrangler.toml [binding](/r2/data-access/workers-api/workers-api-usage/#4-bind-your-bucket-to-a-worker) to whatever bucket represents your "drop box" bucket. Additionally, authorization
is handled in-line with the upload which can reduce latency.

In fact, Workers let you implement certain things more easily. Let's say you wanted
to offer a "write-once" like guarantee so that the you can only upload to a path once. With pre-signed URLs, you
would need to sign specific headers and require the sender to send them which adds some complexity:
```
    const signedUrl = await r2.sign(new Request(
      `https://<DROPBOX BUCKET><ACCOUNT ID>.r2.cloudflarestorage.com${url.pathname}`, {
        method: 'PUT'
      }
    ), {
      signQuery: true,
      headers: {
        // The signed request is valid for 1 hour.
        'X-Amz-Expires': 3600,
        'If-Unmodified-Since': 'Tue, 28 Sep 2021 16:00:00 GMT',
      },
    });
```

Note that the caller has to add the the same `If-Unmodified-Since` header to use the URL (they
can't omit it / use a different header).

In a worker you would simply change your upload to:

```
    const existingObject = await env.DROP_BOX_BUCKET.put(url.substring(1), request.body, {
      onlyIf: {
        // No objects will have been uploaded before September 28th, 2021 which
        // is the initial R2 announcement.
        uploadedBefore: new Date(1632844800000),
      }
    });
    if (existingObject?.etag !== request.headers.get('etag')) {
      return new Response('attempt to overwrite object', { status: 400 })
    }
```

Of course Cloudflare Workers currently have some limitations that you may need to consider.
You can't upload more than 100 MiB (200 MiB for Business) to a Worker (this is a Worker limitation not an R2 one).
ENT customers can upload 500 MiB by default and can ask customer support to help them raise it to whatever
limit they want. Additionally, detecting the precondition failure is currently easier with presigned
URLs as compared with R2 bindings.

Note that this all depends on R2's extension for conditional uploads. Amazon's S3 service does not offer such
functionality at this time.

## Presigned URLs vs Public Buckets

Presigned URLs share some superificial similarity with public buckets. If you hand out presigned URLs only for GET/HEAD
on specific objects of a bucket, then it's mostly similar with the notable exception that any custom metadata associated
with the object is rendered in headers with the `x-amz-meta-` prefix. Any error responses are returned as XML documents
as they would with normal non-presigned S3 access. Presigned URLs can be generated for any S3 operation and once generated
can be reused as many times as the holder of the URL wants until the signed expiry date.

[Public buckets](<link to public bucket>) are available on a regular HTTP endpoint. By default there's no authorization or access controls if someone
knows the URL to an object. If using a custom domain to expose the R2 bucket, then you can manage authorization / access controls
as you would for any Cloudflare zone. Public buckets also only provide `GET`/`HEAD` on a known object path and errors are rendered
as HTML pages. There's no ability to do other operations like list objects, upload objects, create buckets, etc.

Which you should choose is dependent on your specific use-case and you can always combine if your architecture should use
public buckets in one situation and presigned URLs in another. It's useful to note that presigned URLs will expose your
account ID and bucket name to whoever gets a copy. Public bucket URLs do not contain the account ID or bucket name. Typically,
you will not share presigned URLs directly with end users / browsers and it's typically used more for internal applications.

## Generate presigned URLs

Generate a presigned URL by referring to the following examples:

- [AWS SDK for Go](/r2/examples/aws-sdk-go/#generate-presigned-urls)
- [AWS SDK for JS v3](/r2/examples/aws-sdk-js-v3/#generate-presigned-urls)
- [AWS SDK for JS](/r2/examples/aws-sdk-js/#generate-presigned-urls)
- [AWS SDK for PHP](/r2/examples/aws-sdk-php/#generate-presigned-urls)
- [AWS CLI](/r2/examples/aws-cli/#generate-presigned-urls)

## Related resources

- [Create a public bucket](/r2/data-access/public-buckets/)
