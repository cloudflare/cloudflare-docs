[{"description":"When calling `response.blob.type()`, the MIME type will now be properly extracted from `content-type` headers, per the [WHATWG spec](https://fetch.spec.whatwg.org/#concept-header-extract-mime-type).","disable_flag":"blob_legacy_mime_type","enable_date":"2024-06-03","enable_flag":"blob_standard_mime_type","experimental":false,"name":"Properly extract blob MIME type from `content-type` headers"},{"description":"The `fetch_standard_url` flag makes `fetch()` use [WHATWG URL Standard](https://url.spec.whatwg.org/) parsing rules. The original implementation would throw `TypeError: Fetch API cannot load` errors with some URLs where standard parsing does not, for instance with the inclusion of whitespace before the URL. URL errors will now be thrown immediately upon calling `new Request()` with an improper URL. Previously, URL errors were thrown only once `fetch()` was called.","disable_flag":"fetch_legacy_url","enable_date":"2024-06-03","enable_flag":"fetch_standard_url","experimental":false,"name":"Use standard URL parsing in `fetch()`"},{"description":"In the original implementation of BYOB (\"Bring your own buffer\") `ReadableStreams`, the `read()` method would return `undefined` when the stream was closed and there was no more data to read. This behavior was inconsistent with the standard `ReadableStream` behavior, which returns an empty `Uint8Array` when the stream is closed.\n\nWhen the `internal_stream_byob_return_view` flag is used, the BYOB `read()` will implement standard behavior.\n\n```js\nconst resp = await fetch('https://example.org');\nconst reader = resp.body.getReader({ mode: 'byob' });\nawait result = await reader.read(new Uint8Array(10));\n\nif (result.done) {\n  // The result gives us an empty Uint8Array...\n  console.log(result.value.byteLength); // 0\n\n  // However, it is backed by the same underlying memory that was passed\n  // into the read call.\n  console.log(result.value.buffer.byteLength); // 10\n}\n```","disable_flag":"internal_stream_byob_return_undefined","enable_date":"2024-05-13","enable_flag":"internal_stream_byob_return_view","experimental":false,"name":"Returning empty Uint8Array on final BYOB read"},{"description":"When the `brotli_content_encoding` compatibility flag is enabled, Workers supports the `br` content encoding and can request and respond with data encoded using the [Brotli](https://developer.mozilla.org/en-US/docs/Glossary/Brotli_compression) compression algorithm. This reduces the amount of data that needs to be fetched and can be used to pass through the original compressed data to the client. See the Fetch API [documentation](/workers/runtime-apis/fetch/#how-the-accept-encoding-header-is-handled) for details.","disable_flag":"no_brotli_content_encoding","enable_date":"2024-04-29","enable_flag":"brotli_content_encoding","experimental":false,"name":"Brotli Content-Encoding support"},{"description":"With this flag on, [Durable Object](/durable-objects/) stubs and [Service Bindings](/workers/runtime-apis/bindings/service-bindings/) support [RPC](/workers/runtime-apis/rpc/). This means that these objects now appear as if they define every possible method name. Calling any method name sends an RPC to the remote Durable Object or Worker service.\n\nFor most applications, this change will have no impact unless you use it. However, it's possible some existing code will be impacted if it explicitly checks for the existence of method names that were previously not defined on these types. For example, we've seen code in the wild which iterates over [bindings](/workers/runtime-apis/bindings/) and tries to auto-detect their types based on what methods they implement. Such code will now see service bindings as implementing every method, so may misinterpret service bindings as being some other type. In the cases we've seen, the impact was benign (nothing actually broke), but out of caution we are guarding this change behind a flag.","disable_flag":"no_rpc","enable_date":"2024-04-03","enable_flag":"rpc","experimental":false,"name":"Durable Object stubs and Service Bindings support RPC"},{"description":"With the `unwrap_custom_thenables` flag set, various Workers APIs that accept promises will also\ncorrectly handle custom thenables (objects with a `then` method) that are not native promises, but\nare intended to be treated as such). For example, the `waitUntil` method of the `ExecutionContext`\nobject will correctly handle custom thenables, allowing them to be used in place of native promises.\n\n```js\nasync fetch(req, env, ctx) {\n  ctx.waitUntil({ then(res) {\n    // Resolve the thenable after 1 second\n    setTimeout(res, 1000);\n  } });\n  // ...\n}\n```","disable_flag":"no_unwrap_custom_thenables","enable_date":"2024-04-01","enable_flag":"unwrap_custom_thenables","experimental":false,"name":"Handling custom thenables"},{"description":"[Durable Object](/durable-objects/) stubs and [Service Bindings](/workers/runtime-apis/bindings/service-bindings/) both implement a `fetch()` method which behaves similarly to the global `fetch()` method, but requests are instead sent to the destination represented by the object, rather than being routed based on the URL.\n\nHistorically, API objects that had such a `fetch()` method also had methods `get()`, `put()`, and `delete()`. These methods were thin wrappers around `fetch()` which would perform the corresponding HTTP method and automatically handle writing/reading the request/response bodies as needed.\n\nThese methods were a very early idea from many years ago, but were never actually documented, and therefore rarely (if ever) used. Enabling the `fetcher_no_get_put_delete`, or setting a compatibility date on or after `2024-03-26` disables these methods for your Worker.\n\nThis change paves a future path for you to be able to define your own custom methods using these names. Without this change, you would be unable to define your own `get`, `put`, and `delete` methods, since they would conflict with these built-in helper methods.","disable_flag":"fetcher_has_get_put_delete","enable_date":"2024-03-26","enable_flag":"fetcher_no_get_put_delete","experimental":false,"name":"Fetchers no longer have get/put/delete helper methods"},{"description":"With the `queues_json_messages` flag set, Queue bindings will serialize values passed to `send()` or `sendBatch()` into JSON format by default (when no specific `contentType` is provided).","disable_flag":"no_queues_json_messages","enable_date":"2024-03-18","enable_flag":"queues_json_messages","experimental":false,"name":"Queues send messages in `JSON` format"},{"description":"Suppresses the global `importScripts()` function. This method was included in the Workers global scope but was marked explicitly as non-implemented. However, the presence of the function could cause issues with some libraries. This compatibility flag removes the function from the global scope.","disable_flag":"global_importscripts","enable_date":"2024-03-04","enable_flag":"no_global_importscripts","experimental":false,"name":"Suppress global `importScripts()`"},{"description":"Enables the availability of the Node.js [AsyncLocalStorage](https://nodejs.org/api/async_hooks.html#async_hooks_class_asynclocalstorage) API in Workers. This API allows you to store data that is accessible to all asynchronous operations within a given execution context. This is useful for storing data that is relevant to the current request, such as request-specific metadata or tracing information.","disable_flag":"no_nodejs_als","enable_date":null,"enable_flag":"nodejs_als","experimental":false,"name":"Node.js AsyncLocalStorage"},{"description":"This flag enables first class support for Python. [Python Workers](/workers/languages/python/#python) implement the majority of Python's [standard library](/workers/languages/python/stdlib), support all [bindings](/workers/runtime-apis/bindings), [environment variable](/workers/configuration/environment-variables), and [secrets](/workers/configuration/secrets), and integration with JavaScript objects and functions via a [foreign function interface](/workers/languages/python/ffi).","disable_flag":null,"enable_date":"2024-01-29","enable_flag":"python_workers","experimental":false,"name":"Python Workers"},{"description":"In the WebCrypto API, the `publicExponent` field of the algorithm of RSA keys would previously be an `ArrayBuffer`. Using this flag, `publicExponent` is a `Uint8Array` as mandated by the specification.","disable_flag":"no_crypto_preserve_public_exponent","enable_date":"2023-12-01","enable_flag":"crypto_preserve_public_exponent","experimental":false,"name":"WebCrypto preserve publicExponent field"},{"description":"A set value on `vectorize_query_metadata_optional` indicates that the Vectorize query operation should accept newer arguments with `returnValues` and `returnMetadata` specified discretely over the older argument `returnVectors`. This also changes the return format. If the vector values have been indicated for return, the return value is now a flattened vector object with `score` attached where it previously contained a nested vector object.","disable_flag":"vectorize_query_original","enable_date":"2023-11-08","enable_flag":"vectorize_query_metadata_optional","experimental":false,"name":"`Vectorize` query with metadata optionally returned"},{"description":"The Workers runtime did not support WebSocket compression when the initial WebSocket implementation was released. Historically, the runtime has stripped or ignored the `Sec-WebSocket-Extensions` header -- but is now capable of fully complying with the WebSocket Compression RFC. Since many clients are likely sending `Sec-WebSocket-Extensions: permessage-deflate` to their Workers today (`new WebSocket(url)` automatically sets this in browsers), we have decided to maintain prior behavior if this flag is absent.\n\nIf the flag is present, the Workers runtime is capable of using WebSocket Compression on both inbound and outbound WebSocket connections.\n\nLike browsers, calling `new WebSocket(url)` in a Worker will automatically set the `Sec-WebSocket-Extensions: permessage-deflate` header. If you are using the non-standard `fetch()` API to obtain a WebSocket, you can include the `Sec-WebSocket-Extensions` header with value `permessage-deflate` and include any of the compression parameters defined in [RFC-7692](https://datatracker.ietf.org/doc/html/rfc7692#section-7).","disable_flag":"no_web_socket_compression","enable_date":"2023-08-15","enable_flag":"web_socket_compression","experimental":false,"name":"WebSocket Compression"},{"description":"Perform additional error checking in the Web Crypto API to conform with the specification and reject possibly unsafe key parameters:\n- For RSA key generation, key sizes are required to be multiples of 128 bits as boringssl may otherwise truncate the key.\n- The size of imported RSA keys must be at least 256 bits and at most 16384 bits, as with newly generated keys.\n- The public exponent for imported RSA keys is restricted to the commonly used values `[3, 17, 37, 65537]`.\n- In conformance with the specification, an error will be thrown when trying to import a public ECDH key with non-empty usages.","disable_flag":"no_strict_crypto_checks","enable_date":"2023-08-01","enable_flag":"strict_crypto_checks","experimental":false,"name":"Strict crypto error checking"},{"description":"Perform additional error checking in the Compression Streams API and throw an error if a `DecompressionStream` has trailing data or gets closed before the full compressed data has been provided.","disable_flag":"no_strict_compression_checks","enable_date":"2023-08-01","enable_flag":"strict_compression_checks","experimental":false,"name":"Strict compression error checking"},{"description":"This flag streamlines Workers requests by reducing unnecessary properties in the `request.cf` object.\n\nWith the flag enabled - either by default after 2023-08-01 or by setting the `no_cf_botmanagement_default` flag - Cloudflare will only include the [Bot Management object](/bots/reference/bot-management-variables/#bot-management-variables) in a Worker's `request.cf` if the account has access to Bot Management.\n\nWith the flag disabled, Cloudflare will include a default Bot Management object, regardless of whether the account is entitled to Bot Management.","disable_flag":"cf_botmanagement_default","enable_date":"2023-08-01","enable_flag":"no_cf_botmanagement_default","experimental":false,"name":"Bot Management data"},{"description":"The WHATWG introduced additional optional arguments to the `URLSearchParams` object [`delete()`](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams/delete) and [`has()`](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams/has) methods that allow for more precise control over the removal of query parameters. Because\nthe arguments are optional and change the behavior of the methods when present there is a risk of\nbreaking existing code. If your compatibility date is set to July 1, 2023 or after, this compatibility flag will be enabled by default.\n\nFor an example of how this change could break existing code, consider code that uses the `Array` `forEach()` method to iterate through a number of parameters to delete:\n\n```js\nconst usp = new URLSearchParams();\n// ...\n['abc', 'xyz'].forEach(usp.delete.bind(usp));\n```\n\nThe `forEach()` automatically passes multiple parameters to the function that is passed in. Prior to the addition of the new standard parameters, these extra arguments would have been ignored.\n\nNow, however, the additional arguments have meaning and change the behavior of the function. With this flag, the example above would need to be changed to:\n\n```js\nconst usp = new URLSearchParams();\n// ...\n['abc', 'xyz'].forEach((key) =\u003e usp.delete(key));\n```","disable_flag":"no_urlsearchparams_delete_has_value_arg","enable_date":"2023-07-01","enable_flag":"urlsearchparams_delete_has_value_arg","experimental":false,"name":"URLSearchParams delete() and has() value argument"},{"description":"Change the URL implementation used in `Response.redirect()` to be spec-compliant (WHATWG URL Standard).","disable_flag":"response_redirect_url_original","enable_date":"2023-03-14","enable_flag":"response_redirect_url_standard","experimental":false,"name":"Use a spec compliant URL implementation in redirects"},{"description":"Previously, when using Workers for Platforms' [dynamic dispatch API](/cloudflare-for-platforms/workers-for-platforms/get-started/dynamic-dispatch/) to send an HTTP request to a user Worker, if the user Worker threw an exception, the dynamic dispatch Worker would receive an HTTP `500` error with no body. When the `dynamic_dispatch_tunnel_exceptions` compatibility flag is enabled, the exception will instead propagate back to the dynamic dispatch Worker. The `fetch()` call in the dynamic dispatch Worker will throw the same exception. This matches the similar behavior of [service bindings](/workers/runtime-apis/bindings/service-bindings/#service-bindings) and [Durable Objects](/durable-objects/).","disable_flag":"dynamic_dispatch_treat_exceptions_as_500","enable_date":"2023-03-01","enable_flag":"dynamic_dispatch_tunnel_exceptions","experimental":false,"name":"Dynamic Dispatch Exception Propagation"},{"description":"Adds the [`getSetCookie()`](https://developer.mozilla.org/en-US/docs/Web/API/Headers/getSetCookie) method to the [Headers](https://developer.mozilla.org/en-US/docs/Web/API/Headers) API in Workers.\n\n```js\nconst response = await fetch(\"https://example.com\");\nlet cookieValues = response.headers.getSetCookie();\n```","disable_flag":"no_http_headers_getsetcookie","enable_date":"2023-03-01","enable_flag":"http_headers_getsetcookie","experimental":false,"name":"`Headers` supports `getSetCookie()`"},{"description":"Enables the full set of [available Node.js APIs](/workers/runtime-apis/nodejs/) in the Workers Runtime.","disable_flag":"no_nodejs_compat","enable_date":null,"enable_flag":"nodejs_compat","experimental":false,"name":"Node.js compatibility"},{"description":"Adds the work-in-progress `new ReadableStream()` and `new WritableStream()` constructors backed by JavaScript underlying sources and sinks.","disable_flag":"streams_disable_constructors","enable_date":"2022-11-30","enable_flag":"streams_enable_constructors","experimental":false,"name":"Streams Constructors"},{"description":"Previously, the `new TransformStream()` constructor was not compliant with the Streams API standard. Use the `transformstream_enable_standard_constructor` to opt-in to the backwards-incompatible change to make the constructor compliant. Must be used in combination with the `streams_enable_constructors` flag.","disable_flag":"transformstream_disable_standard_constructor","enable_date":"2022-11-30","enable_flag":"transformstream_enable_standard_constructor","experimental":false,"name":"Compliant TransformStream constructor"},{"description":"CommonJS modules were previously exporting a module namespace (an object like `{ default: module.exports }`) rather than exporting only the `module.exports`. When this flag is enabled, the export is fixed.","disable_flag":"export_commonjs_namespace","enable_date":"2022-10-31","enable_flag":"export_commonjs_default","experimental":false,"name":"CommonJS modules do not export a module namespace"},{"description":"The `capture_async_api_throws` compatibility flag will ensure that, in conformity with the standards API, async functions will only ever reject if they throw an error. The inverse `do_not_capture_async_api_throws` flag means that async functions which contain an error may throw that error synchronously rather than rejecting.","disable_flag":"do_not_capture_async_api_throws","enable_date":"2022-10-31","enable_flag":"capture_async_api_throws","experimental":false,"name":"Do not throw from async functions"},{"description":"The original implementation of the [`URL`](https://developer.mozilla.org/en-US/docs/Web/API/URL) API in Workers was not fully compliant with the [WHATWG URL Standard](https://url.spec.whatwg.org/), differing in several ways, including:\n\n* The original implementation collapsed sequences of multiple slashes into a single slash:\n\n  `new URL(\"https://example.com/a//b\").toString() === \"https://example.com/a/b\"`\n\n* The original implementation would throw `\"TypeError: Invalid URL string.\"` if it encountered invalid percent-encoded escape sequences, like `https://example.com/a%%b`.\n\n* The original implementation would percent-encode or percent-decode certain content differently:\n\n  `new URL(\"https://example.com/a%40b?c d%20e?f\").toString() === \"https://example.com/a@b?c+d+e%3Ff\"`\n\n* The original implementation lacked more recently implemented `URL` features, like [`URL.canParse()`](https://developer.mozilla.org/en-US/docs/Web/API/URL/canParse_static).\n\nSet the compatibility date of your Worker to a date after `2022-10-31` or enable the `url_standard` compatibility flag to opt-in the fully spec compliant `URL` API implementation.\n\nRefer to the [`response_redirect_url_standard` compatibility flag](/workers/configuration/compatibility-dates/#use-a-spec-compliant-url-implementation-in-redirects) , which affects the URL implementation used in `Response.redirect()`.","disable_flag":"url_original","enable_date":"2022-10-31","enable_flag":"url_standard","experimental":false,"name":"New URL parser implementation"},{"description":"With the `r2_list_honor_include` flag set, the `include` argument to R2 `list` options is honored. With an older compatibility date and without this flag, the `include` argument behaves implicitly as `include: [\"httpMetadata\", \"customMetadata\"]`.","disable_flag":null,"enable_date":"2022-08-04","enable_flag":"r2_list_honor_include","experimental":false,"name":"`R2` bucket `list` respects the `include` option"},{"description":"There was a bug in the runtime that meant that when being passed into built-in APIs, invalid values were sometimes mistakenly coalesced with `null`. Instead, a `TypeError` should have been thrown. The `dont_substitute_null_on_type_error` fixes this behavior so that an error is correctly thrown in these circumstances.","disable_flag":"substitute_null_on_type_error","enable_date":"2022-06-01","enable_flag":"dont_substitute_null_on_type_error","experimental":false,"name":"Do not substitute `null` on `TypeError`"},{"description":"With the `minimal_subrequests` flag set, `fetch()` subrequests sent to endpoints on the Worker's own zone (also called same-zone subrequests) have a reduced set of features applied to them. In general, these features should not have been initially applied to same-zone subrequests, and very few user-facing behavior changes are anticipated. Specifically, Workers might observe the following behavior changes with the new flag:\n\n- Response bodies will not be opportunistically gzipped before being transmitted to the Workers runtime. If a Worker reads the response body, it will read it in plaintext, as has always been the case, so disabling this prevents unnecessary decompression. Meanwhile, if the Worker passes the response through to the client, Cloudflare's HTTP proxy will opportunistically gzip the response body on that side of the Workers runtime instead. The behavior change observable by a Worker script should be that some `Content-Encoding: gzip` headers will no longer appear.\n- Automatic Platform Optimization may previously have been applied on both the Worker's initiating request and its subrequests in some circumstances. It will now only apply to the initiating request.\n- Link prefetching will now only apply to the Worker's response, not responses to the Worker's subrequests.","disable_flag":"no_minimal_subrequests","enable_date":"2022-04-05","enable_flag":"minimal_subrequests","experimental":false,"name":"Minimal subrequests"},{"description":"With the `global_navigator` flag set, a new global `navigator` property is available from within Workers. Currently, it exposes only a single `navigator.userAgent` property whose value is set to `'Cloudflare-Workers'`. This property can be used to reliably determine whether code is running within the Workers environment.","disable_flag":"no_global_navigator","enable_date":"2022-03-21","enable_flag":"global_navigator","experimental":false,"name":"Global `navigator`"},{"description":"The `no_cots_on_external_fetch` flag disables the use of the [Custom Origin Trust Store](/ssl/origin-configuration/custom-origin-trust-store/) when making external (grey-clouded) subrequests from a Cloudflare Worker.","disable_flag":"cots_on_external_fetch","enable_date":"2022-03-08","enable_flag":"no_cots_on_external_fetch","experimental":false,"name":"Do not use the Custom Origin Trust Store for external subrequests"},{"description":"Originally, properties on Workers API objects were defined as instance properties as opposed to prototype properties. This broke subclassing at the JavaScript layer, preventing a subclass from correctly overriding the superclass getters/setters. This flag controls the breaking change made to set those getters/setters on the prototype template instead.\n\nThis changes applies to:\n\n- `AbortSignal`\n- `AbortController`\n- `Blob`\n- `Body`\n- `DigestStream`\n- `Event`\n- `File`\n- `Request`\n- `ReadableStream`\n- `ReadableStreamDefaultReader`\n- `ReadableStreamBYOBReader`\n- `Response`\n- `TextDecoder`\n- `TextEncoder`\n- `TransformStream`\n- `URL`\n- `WebSocket`\n- `WritableStream`\n- `WritableStreamDefaultWriter`","disable_flag":"workers_api_getters_setters_on_instance","enable_date":"2022-01-31","enable_flag":"workers_api_getters_setters_on_prototype","experimental":false,"name":"Setters/getters on API object prototypes"},{"description":"Originally, when making a request to a Durable Object by calling `stub.fetch(url)`, a relative URL was accepted as an input. The URL would be interpreted relative to the dummy URL `http://fake-host`, and the resulting absolute URL was delivered to the destination object's `fetch()` handler. This was a mistake — full URLs were meant to be required. This flag makes full URLs required.","disable_flag":"durable_object_fetch_allows_relative_url","enable_date":"2021-11-10","enable_flag":"durable_object_fetch_requires_full_url","experimental":false,"name":"Durable Object `stub.fetch()` requires a full URL"},{"description":"Originally, if the `fetch()` function was passed a URL specifying any protocol other than `http:` or `https:`, it would silently treat it as if it were `http:`. For example, `fetch()` would appear to accept `ftp:` URLs, but it was actually making HTTP requests instead.\n\nNote that Cloudflare Workers supports a non-standard extension to `fetch()` to make it support WebSockets. However, when making an HTTP request that is intended to initiate a WebSocket handshake, you should still use `http:` or `https:` as the protocol, not `ws:` nor `wss:`.\n\nThe `ws:` and `wss:` URL schemes are intended to be used together with the `new WebSocket()` constructor, which exclusively supports WebSocket. The extension to `fetch()` is designed to support HTTP and WebSocket in the same request (the response may or may not choose to initiate a WebSocket), and so all requests are considered to be HTTP.","disable_flag":"fetch_treats_unknown_protocols_as_http","enable_date":"2021-11-10","enable_flag":"fetch_refuses_unknown_protocols","experimental":false,"name":"`fetch()` improperly interprets unknown protocols as HTTP"},{"description":"Originally, the Workers runtime did not detach the `ArrayBuffer`s from user-provided TypedArrays when using the [BYOB reader's `read()` method](/workers/runtime-apis/streams/readablestreambyobreader/#methods), as required by the Streams spec, meaning it was possible to inadvertently reuse the same buffer for multiple `read()` calls. This change makes Workers conform to the spec.\n\nUser code should never try to reuse an `ArrayBuffer` that has been passed into a [BYOB reader's `read()` method](/workers/runtime-apis/streams/readablestreambyobreader/#methods). Instead, user code can reuse the `ArrayBuffer` backing the result of the `read()` promise, as in the example below.\n\n```js\n// Consume and discard `readable` using a single 4KiB buffer.\nlet reader = readable.getReader({ mode: \"byob\" });\nlet arrayBufferView = new Uint8Array(4096);\nwhile (true) {\n  let result = await reader.read(arrayBufferView);\n  if (result.done) break;\n  // Optionally something with `result` here.\n  // Re-use the same memory for the next `read()` by creating\n  // a new Uint8Array backed by the result's ArrayBuffer.\n  arrayBufferView = new Uint8Array(result.value.buffer);\n}\n```\n\nThe more recently added extension method `readAtLeast()` will always detach the `ArrayBuffer` and is unaffected by this feature flag setting.","disable_flag":"streams_byob_reader_does_not_detach_buffer","enable_date":"2021-11-10","enable_flag":"streams_byob_reader_detaches_buffer","experimental":false,"name":"Streams BYOB reader detaches buffer"},{"description":"[The `FormData` API](https://developer.mozilla.org/en-US/docs/Web/API/FormData) is used to parse data (especially HTTP request bodies) in `multipart/form-data` format.\n\nOriginally, the Workers runtime's implementation of the `FormData` API incorrectly converted uploaded files to strings. Therefore, `formData.get(\"filename\")` would return a string containing the file contents instead of a `File` object. This change fixes the problem, causing files to be represented using `File` as specified in the standard.","disable_flag":"formdata_parser_converts_files_to_strings","enable_date":"2021-11-03","enable_flag":"formdata_parser_supports_files","experimental":false,"name":"`FormData` parsing supports `File`"},{"description":"The HTML5 standard defines a fixed set of elements as void elements, meaning they do not use an end tag: `\u003carea\u003e`, `\u003cbase\u003e`, `\u003cbr\u003e`, `\u003ccol\u003e`, `\u003ccommand\u003e`, `\u003cembed\u003e`, `\u003chr\u003e`, `\u003cimg\u003e`, `\u003cinput\u003e`, `\u003ckeygen\u003e`, `\u003clink\u003e`, `\u003cmeta\u003e`, `\u003cparam\u003e`, `\u003csource\u003e`, `\u003ctrack\u003e`, and `\u003cwbr\u003e`.\n\nHTML5 does not recognize XML self-closing tag syntax. For example, `\u003cscript src=\"foo.js\" /\u003e` does not specify a script element with no body. A `\u003c/script\u003e` ending tag is still required. The `/\u003e` syntax simply is not recognized by HTML5 at all and it is treated the same as `\u003e`. However, many developers still like to use this syntax, as a holdover from XHTML, a standard which failed to gain traction in the early 2000's.\n\n`\u003cesi:include\u003e` and `\u003cesi:comment\u003e` are two tags that are not part of the HTML5 standard, but are instead used as part of [Edge Side Includes](https://en.wikipedia.org/wiki/Edge_Side_Includes), a technology for server-side HTML modification. These tags are not expected to contain any body and are commonly written with XML self-closing syntax.\n\n`HTMLRewriter` was designed to parse standard HTML5, not ESI. However, it would be useful to be able to implement some parts of ESI using `HTMLRewriter`. To that end, this compatibility flag causes `HTMLRewriter` to treat `\u003cesi:include\u003e` and `\u003cesi:comment\u003e` as void tags, so that they can be parsed and handled properly.","disable_flag":null,"enable_date":null,"enable_flag":"html_rewriter_treats_esi_include_as_void_tag","experimental":true,"name":"`HTMLRewriter` handling of `\u003cesi:include\u003e`"}]